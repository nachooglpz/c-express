#include "../src/core/app.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Sample data in different formats for content negotiation
const char* users_json = "{"
    "\"users\": ["
        "{"
            "\"id\": 1,"
            "\"name\": \"John Doe\","
            "\"email\": \"john@example.com\","
            "\"role\": \"admin\""
        "},"
        "{"
            "\"id\": 2,"
            "\"name\": \"Jane Smith\","
            "\"email\": \"jane@example.com\","
            "\"role\": \"user\""
        "}"
    "],"
    "\"total\": 2"
"}";

const char* users_html = "<!DOCTYPE html>"
"<html>"
"<head>"
    "<title>Users List</title>"
    "<style>"
        "body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }"
        "h1 { color: #333; border-bottom: 2px solid #007acc; padding-bottom: 10px; }"
        "table { border-collapse: collapse; width: 100%; background-color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }"
        "th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }"
        "th { background-color: #007acc; color: white; font-weight: bold; }"
        "tr:nth-child(even) { background-color: #f2f2f2; }"
        "tr:hover { background-color: #e8f4f8; }"
        ".admin { color: #d32f2f; font-weight: bold; }"
        ".user { color: #388e3c; }"
        ".footer { margin-top: 20px; color: #666; font-style: italic; }"
    "</style>"
"</head>"
"<body>"
    "<h1>C-Express Users List</h1>"
    "<table>"
        "<tr><th>ID</th><th>Name</th><th>Email</th><th>Role</th></tr>"
        "<tr><td>1</td><td>John Doe</td><td>john@example.com</td><td class='admin'>admin</td></tr>"
        "<tr><td>2</td><td>Jane Smith</td><td>jane@example.com</td><td class='user'>user</td></tr>"
    "</table>"
    "<div class='footer'>"
        "<p>Total users: 2 | Generated by C-Express Content Negotiation</p>"
        "<p>Try different Accept headers: application/json, application/xml, text/plain</p>"
    "</div>"
"</body>"
"</html>";

const char* users_text = "C-EXPRESS USERS LIST\n"
"========================\n\n"
"   User #1:\n"
"   ID: 1\n"
"   Name: John Doe\n"
"   Email: john@example.com\n"
"   Role: admin\n\n"
"   User #2:\n"
"   ID: 2\n"
"   Name: Jane Smith\n"
"   Email: jane@example.com\n"
"   Role: user\n\n"
"   Summary:\n"
"   Total users: 2\n"
"   Generated: C-Express Content Negotiation Demo\n"
"   Format: Plain Text\n";

const char* users_xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
"<users>"
    "<metadata>"
        "<total>2</total>"
        "<generated-by>C-Express Content Negotiation</generated-by>"
        "<format>XML</format>"
    "</metadata>"
    "<user id=\"1\">"
        "<name>John Doe</name>"
        "<email>john@example.com</email>"
        "<role>admin</role>"
    "</user>"
    "<user id=\"2\">"
        "<name>Jane Smith</name>"
        "<email>jane@example.com</email>"
        "<role>user</role>"
    "</user>"
"</users>";

const char* users_csv = "ID,Name,Email,Role\n"
"1,\"John Doe\",john@example.com,admin\n"
"2,\"Jane Smith\",jane@example.com,user\n";

// Simple content type detection from Accept header
const char* get_preferred_content_type(const char* accept_header) {
    if (!accept_header) {
        return "application/json";  // default
    }
    
    printf("[DEBUG] Content Negotiation - Accept header: %s\n", accept_header);
    
    // Check for specific types with quality value awareness
    if (strstr(accept_header, "application/json")) {
        return "application/json";
    } else if (strstr(accept_header, "text/html")) {
        return "text/html";
    } else if (strstr(accept_header, "application/xml")) {
        return "application/xml";
    } else if (strstr(accept_header, "text/plain")) {
        return "text/plain";
    } else if (strstr(accept_header, "text/csv")) {
        return "text/csv";
    } else if (strstr(accept_header, "text/*")) {
        return "text/html";  // prefer HTML for text wildcards
    } else if (strstr(accept_header, "application/*")) {
        return "application/json";  // prefer JSON for application wildcards
    } else if (strstr(accept_header, "*/*")) {
        return "application/json";  // prefer JSON for general wildcards
    }
    
    return "application/json";  // fallback
}

// Main content negotiation handler - supports multiple formats
void content_negotiation_handler(int client_fd, void (*next)(void *), void *context) {
    (void)next;
    (void)client_fd;
    
    NextContext *ctx = (NextContext *)context;
    Request *req = ctx->req;
    Response *res = (Response *)ctx->user_context;
    
    printf("\n[DEBUG] === Content Negotiation Handler ===\n");
    
    // Get the Accept header
    const char *accept_header = req->get_header(req, "Accept");
    const char *content_type = get_preferred_content_type(accept_header);
    
    printf("[DEBUG] Negotiated content type: %s\n", content_type);
    
    // Set response headers
    response_set_header(res, "Content-Type", content_type);
    response_set_header(res, "X-Content-Negotiated", "true");
    response_set_header(res, "X-Available-Types", "application/json, text/html, application/xml, text/plain, text/csv");
    
    // Send appropriate content based on negotiated type
    if (strcmp(content_type, "application/json") == 0) {
        response_send(res, users_json);
    } else if (strcmp(content_type, "text/html") == 0) {
        response_send(res, users_html);
    } else if (strcmp(content_type, "application/xml") == 0) {
        response_send(res, users_xml);
    } else if (strcmp(content_type, "text/plain") == 0) {
        response_send(res, users_text);
    } else if (strcmp(content_type, "text/csv") == 0) {
        response_set_header(res, "Content-Disposition", "attachment; filename=\"users.csv\"");
        response_send(res, users_csv);
    } else {
        // Fallback to JSON
        response_set_header(res, "Content-Type", "application/json");
        response_send(res, users_json);
    }
}

// Handler to analyze Accept header and show negotiation details
void accept_analysis_handler(int client_fd, void (*next)(void *), void *context) {
    (void)next;
    (void)client_fd;
    
    NextContext *ctx = (NextContext *)context;
    Request *req = ctx->req;
    Response *res = (Response *)ctx->user_context;
    
    printf("\n[DEBUG] === Accept Analysis Handler ===\n");
    
    const char *accept_header = req->get_header(req, "Accept");
    
    // Analyze different content types
    int accepts_json = accept_header && strstr(accept_header, "application/json");
    int accepts_html = accept_header && strstr(accept_header, "text/html");
    int accepts_xml = accept_header && strstr(accept_header, "application/xml");
    int accepts_text = accept_header && strstr(accept_header, "text/plain");
    int accepts_csv = accept_header && strstr(accept_header, "text/csv");
    int accepts_any = accept_header && strstr(accept_header, "*/*");
    int accepts_text_wildcard = accept_header && strstr(accept_header, "text/*");
    int accepts_app_wildcard = accept_header && strstr(accept_header, "application/*");
    
    char response[1024];
    snprintf(response, sizeof(response),
        "{"
        "\"accept_header\": \"%s\","
        "\"analysis\": {"
            "\"accepts_json\": %s,"
            "\"accepts_html\": %s,"
            "\"accepts_xml\": %s,"
            "\"accepts_text\": %s,"
            "\"accepts_csv\": %s,"
            "\"accepts_any_wildcard\": %s,"
            "\"accepts_text_wildcard\": %s,"
            "\"accepts_app_wildcard\": %s"
        "},"
        "\"recommended_type\": \"%s\","
        "\"available_endpoints\": ["
            "\"/api/users (supports: JSON, HTML, XML, Text, CSV)\","
            "\"/api/json-only (JSON only, returns 406 for others)\","
            "\"/api/versioned (API versioning demo)\""
        "]"
        "}",
        accept_header ? accept_header : "none (defaults to application/json)",
        accepts_json ? "true" : "false",
        accepts_html ? "true" : "false",
        accepts_xml ? "true" : "false",
        accepts_text ? "true" : "false",
        accepts_csv ? "true" : "false",
        accepts_any ? "true" : "false",
        accepts_text_wildcard ? "true" : "false",
        accepts_app_wildcard ? "true" : "false",
        get_preferred_content_type(accept_header)
    );
    
    response_set_header(res, "Content-Type", "application/json");
    response_send(res, response);
}

// Handler that only accepts JSON (demonstrates 406 Not Acceptable)
void json_only_handler(int client_fd, void (*next)(void *), void *context) {
    (void)next;
    (void)client_fd;
    
    NextContext *ctx = (NextContext *)context;
    Request *req = ctx->req;
    Response *res = (Response *)ctx->user_context;
    
    printf("\n[DEBUG] === JSON Only Handler ===\n");
    
    const char *accept_header = req->get_header(req, "Accept");
    printf("[DEBUG] Checking if client accepts JSON...\n");
    
    // Check if client accepts JSON
    int accepts_json = !accept_header || 
                      strstr(accept_header, "application/json") ||
                      strstr(accept_header, "*/*") ||
                      strstr(accept_header, "application/*");
    
    if (!accepts_json) {
        printf("[DEBUG] Client does not accept JSON, returning 406\n");
        // Return 406 Not Acceptable
        response_status(res, 406);
        response_set_header(res, "Content-Type", "application/json");
        response_set_header(res, "X-Error-Reason", "Content type not acceptable");
        
        char error_response[512];
        snprintf(error_response, sizeof(error_response), "{"
            "\"error\": \"Not Acceptable\","
            "\"status_code\": 406,"
            "\"message\": \"This endpoint only supports application/json\","
            "\"supported_types\": [\"application/json\"],"
            "\"your_accept_header\": \"%s\""
        "}", accept_header ? accept_header : "none");
        
        response_send(res, error_response);
        return;
    }
    
    printf("[DEBUG] Client accepts JSON, sending response\n");
    // Send JSON response
    response_set_header(res, "Content-Type", "application/json");
    response_send(res, "{"
        "\"message\": \"JSON-only endpoint working correctly\","
        "\"data\": {"
            "\"status\": \"success\","
            "\"format\": \"json\","
            "\"endpoint_type\": \"restricted\""
        "},"
        "\"accepted_your_request\": true"
    "}");
}

// API versioning handler using vendor MIME types
void api_versioned_handler(int client_fd, void (*next)(void *), void *context) {
    (void)next;
    (void)client_fd;
    
    NextContext *ctx = (NextContext *)context;
    Request *req = ctx->req;
    Response *res = (Response *)ctx->user_context;
    
    printf("\n[DEBUG] === API Versioned Handler ===\n");
    
    const char *accept_header = req->get_header(req, "Accept");
    int api_version = 1;  // default
    const char *content_type = "application/json";
    
    if (accept_header) {
        printf("[DEBUG] Checking for API version in Accept header...\n");
        if (strstr(accept_header, "application/vnd.api.v2+json")) {
            api_version = 2;
            content_type = "application/vnd.api.v2+json";
        } else if (strstr(accept_header, "application/vnd.api.v3+json")) {
            api_version = 3;
            content_type = "application/vnd.api.v3+json";
        }
    }
    
    printf("[DEBUG] Selected API version: v%d\n", api_version);
    
    char response[512];
    char version_header[16];
    snprintf(version_header, sizeof(version_header), "v%d", api_version);
    
    switch (api_version) {
        case 2:
            snprintf(response, sizeof(response),
                "{"
                "\"version\": \"v2\","
                "\"features\": [\"enhanced_data\", \"bulk_operations\", \"caching\"],"
                "\"users_count\": 2,"
                "\"api_level\": \"advanced\","
                "\"capabilities\": {"
                    "\"rate_limiting\": true,"
                    "\"webhooks\": true,"
                    "\"analytics\": true"
                "}"
                "}");
            break;
        case 3:
            snprintf(response, sizeof(response),
                "{"
                "\"version\": \"v3\","
                "\"features\": [\"graphql\", \"real_time\", \"webhooks\", \"ai_integration\"],"
                "\"users_count\": 2,"
                "\"api_level\": \"enterprise\","
                "\"capabilities\": {"
                    "\"graphql_endpoint\": \"/graphql\","
                    "\"websocket_support\": true,"
                    "\"ai_powered_search\": true,"
                    "\"advanced_analytics\": true"
                "}"
                "}");
            break;
        default:
            snprintf(response, sizeof(response),
                "{"
                "\"version\": \"v1\","
                "\"features\": [\"basic_crud\", \"authentication\"],"
                "\"users_count\": 2,"
                "\"api_level\": \"standard\","
                "\"note\": \"For advanced features, use Accept: application/vnd.api.v2+json or v3+json\""
                "}");
            break;
    }
    
    response_set_header(res, "Content-Type", content_type);
    response_set_header(res, "X-API-Version", version_header);
    response_set_header(res, "X-Available-Versions", "v1, v2, v3");
    response_send(res, response);
}

int main() {
    printf("=== Testing Content Negotiation ===\n\n");
    
    App app = create_app();
    
    printf("Setting up Content Negotiation endpoints...\n\n");
    
    // Main content negotiation endpoint
    printf("  GET /api/users - Full content negotiation (JSON/HTML/XML/Text/CSV)\n");
    app.get(&app, "/api/users", content_negotiation_handler);
    
    // Accept header analysis
    printf("  GET /api/analyze - Accept header analysis and capabilities\n");
    app.get(&app, "/api/analyze", accept_analysis_handler);
    
    // JSON-only endpoint
    printf("  GET /api/json-only - JSON-only endpoint (406 Not Acceptable for others)\n");
    app.get(&app, "/api/json-only", json_only_handler);
    
    // API versioning endpoint
    printf("  GET /api/versioned - API versioning with vendor MIME types\n");
    app.get(&app, "/api/versioned", api_versioned_handler);
    
    printf("\n=== Content Negotiation Features ===\n");
    printf("✓ Accept header parsing and content type selection\n");
    printf("✓ Multiple format support (JSON, HTML, XML, Text, CSV)\n");
    printf("✓ Wildcard matching (*/*, text/*, application/*)\n");
    printf("✓ Quality value awareness (q= parameters)\n");
    printf("✓ Content type rejection (406 Not Acceptable)\n");
    printf("✓ API versioning with vendor MIME types\n");
    printf("✓ Detailed debug logging for negotiation process\n");
    printf("✓ Custom response headers for client guidance\n\n");
    
    printf("=== Test Commands ===\n");
    printf("Server will start on http://localhost:3000\n\n");
    
    printf("1. Request JSON (default/explicit):\n");
    printf("   curl -H 'Accept: application/json' http://localhost:3000/api/users\n");
    printf("   curl http://localhost:3000/api/users\n\n");
    
    printf("2. Request HTML (browser-like):\n");
    printf("   curl -H 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8' http://localhost:3000/api/users\n");
    printf("   curl -H 'Accept: text/html' http://localhost:3000/api/users\n\n");
    
    printf("3. Request XML:\n");
    printf("   curl -H 'Accept: application/xml' http://localhost:3000/api/users\n\n");
    
    printf("4. Request plain text:\n");
    printf("   curl -H 'Accept: text/plain' http://localhost:3000/api/users\n\n");
    
    printf("5. Request CSV (for data export):\n");
    printf("   curl -H 'Accept: text/csv' http://localhost:3000/api/users\n\n");
    
    printf("6. Wildcard requests:\n");
    printf("   curl -H 'Accept: text/*' http://localhost:3000/api/users\n");
    printf("   curl -H 'Accept: application/*' http://localhost:3000/api/users\n");
    printf("   curl -H 'Accept: */*' http://localhost:3000/api/users\n\n");
    
    printf("7. Analyze Accept header capabilities:\n");
    printf("   curl -H 'Accept: application/json;q=0.9, text/html;q=0.8, text/plain;q=0.5' http://localhost:3000/api/analyze\n");
    printf("   curl -H 'Accept: text/*' http://localhost:3000/api/analyze\n\n");
    
    printf("8. JSON-only endpoint tests:\n");
    printf("   curl -H 'Accept: application/json' http://localhost:3000/api/json-only\n");
    printf("   curl -H 'Accept: text/html' http://localhost:3000/api/json-only  # Returns 406\n");
    printf("   curl -H 'Accept: application/xml' http://localhost:3000/api/json-only  # Returns 406\n\n");
    
    printf("9. API versioning with vendor MIME types:\n");
    printf("   curl -H 'Accept: application/json' http://localhost:3000/api/versioned\n");
    printf("   curl -H 'Accept: application/vnd.api.v2+json' http://localhost:3000/api/versioned\n");
    printf("   curl -H 'Accept: application/vnd.api.v3+json' http://localhost:3000/api/versioned\n\n");
    
    printf("10. View response headers (includes negotiation metadata):\n");
    printf("    curl -I -H 'Accept: application/json' http://localhost:3000/api/users\n");
    printf("    curl -I -H 'Accept: text/html' http://localhost:3000/api/users\n\n");
    
    printf("11. Quality value examples:\n");
    printf("    curl -H 'Accept: application/json;q=1.0, text/html;q=0.8, text/plain;q=0.5' http://localhost:3000/api/users\n");
    printf("    curl -H 'Accept: text/html;q=0.5, application/json;q=0.9' http://localhost:3000/api/users\n\n");
    
    app_listen(&app, 3000);
    
    return 0;
}
